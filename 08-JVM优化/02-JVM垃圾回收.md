###JVM垃圾回收    

<a href="#part1"/>
**1.Java语言的垃圾回收**

<a href="#part2"/>
**2.常见的垃圾回收算法**     

<a href="#part3"/>
**3.垃圾收集器以及内存分配**

<a href="#part4"/>
**4. GC Easy 可视化工具**

<a id="part1"/>
**1.Java语言的垃圾回收**  

- 在C/C++语言中，没有自动垃圾回收机制，是通过new关键字申请内存资源，通过
	delete关键字释放内存资源。如果程序员在某些位置没有写delete进行释放，  
	那么申请的对象将一直占用内存资源，最终可能导致内存溢出     

- Java为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，   
	在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC。    
	有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动  
	识别完成。换句话说，自动的垃圾回收的算法就会变得非常重要了，如果因为算法  
	的不合理，导致内存资源一直没有释放，同样也可能会导致内存溢出。  
	当然，除了Java语言，C#、Python等语言也都有自动的垃圾回收机制      


<a id="part2"/>
**2.常见的垃圾回收算法**   

> 2.1 引用计数法  
  原理：假设有一个对象A,任何一个对象对A的引用，那么对象A的引用计数器+1，  
  当引用失败时，对象A的引用计数器就-1，如果对象A的计数器的值为0，就说明对象A  
  没有引用了，可以被回收   

优点：
  
-  实时性较高，无需等到内存不够的时候，才开始回收，运行时根据对象的计数器是否为0，就可以直接回收    
-  在垃圾回收的过程中，应用无需挂起。如果申请内存时，内存不足，则立刻报out of memory 错误   
-  区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象   

缺点：  

-  每次对象被引用时，都需要去更新计数器，有一点时间开销  
-  浪费CPU资源，即使内存够用，仍然在运行时进行计数器的统计  
-  无法解决循环引用问题（最大的缺点，A对象引用B,B对象引用A,A、B都置为null的时候，计数器也不为0，不能被回收）   
   

> 2.2 标记清除法  
  标记清除算法，是将垃圾回收分为2个阶段，分别是标记和清除 
  
- 标记：从根节点开始标记引用的对象
- 清除：从未被标记引用的对象就是垃圾对象，可以被清理      

优点： 

-  解决了引用计数算法中的循环引用的问题，没有从root节点引用的对象都会被回收  

缺点： 

- 效率较低，标记和清除两个动作都需要遍历所有的对象，并且在GC时，需要暂停应用程序，   
对于交互性要求比较高的应用而言这个体验是非常差的   

- 通过标记清除算法清理出来的内存，碎片化较为严重，因为被回收的对象可能给存在于内存的各个角落，所以清理出来的内存是不连贯的   

> 2.3 标记压缩算法   
标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法。和标记清除算法一样，  
也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的清理未标记的对象，  
而是将存活的对象压缩到内存的一端，然后清理边界以外的垃圾，从而解决了碎片化的问题

优点： 

- 解决了标记清除算法的碎片化的问题  

缺点： 

- 标记压缩算法多了一步，对象移动内存位置的步骤，其效率也有一定的影响    

> 2.4 复制算法    
  复制算法的核心就是，将原有的内存空间一分为二，每次只用其中一块，在垃圾回收时，   
  将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。对内存中年轻代的survivor0 和 survivor1 区就是这种算法。

优点： 

- 在垃圾对象多的情况下，效率较高
- 清理后，内存无碎片  

缺点： 

- 在垃圾对象少的情况下，不适合，如：年老代内存   
- 分配的2块内存空间，在同一时刻，只能使用一半，内存使用率较低
   

> 2.5 分代算法   
  前面介绍了多种回收算法，每一种算法都有自己的优点也有缺点，谁都不能替代谁，   
  需要根据垃圾回收对象的特点进行选择，才是明智的选择   

  分代算法其实就是这样，根据回收对象的特点进行选择，在jvm中，年轻代适合使用复制算法（Survivor区），老年代适合标记清除或者标记压缩算法   


<a id="part3"/>
**3.垃圾收集器以及内存分配**   

垃圾回收算法，需要有具体的实现，在jvm中，实现了多种垃圾收集器，包括：串行垃圾收集器、并行垃圾收集器、CMS(并发)垃圾收集器、G1垃圾收集器。    

> 3.1 串行垃圾收集器   
  是指使用单线程进行垃圾回收，垃圾回收时只有一个线程在工作，并且java应用中的所有线程都要暂停，等待垃圾回收完成。这种线程称之为STW(stop-the-world)    
  对于交互性较强的应用而言，这种垃圾收集器是不能够接受的，一般javaweb应用中时不会采用该收集器的   
           
- -XX:+UseSerialGC   
	- 指定年轻代和老年代都使用串行垃圾收集器      
- -XX:+PrintGCDetails  
	- 打印垃圾回收的详细信息     

日志解读： 

- DefNew
	- 表示使用的是串行垃圾收集器  
- Full GC 
	- 表示内存空间全部进行GC，包括年轻代和老年代   

> 3.2 并行垃圾收集器  
  并行垃圾收集器在串行垃圾收集器的基础之上做了改进，将单线程改为了多线程进行垃圾回收，缩短垃圾回收时间，但是在垃圾收集的过程中也会暂停应用程序，暂停时间比串行垃圾收集器短   

- 3.2.1 ParNew 垃圾收集器   
  ParNew并行垃圾收集器是工作在年轻代上，只是将串行的垃圾收集器改为了并行    
	- -XX:+UseParNewGC ：参数设置年轻代使用ParNew回收器，老年代使用的依然是串行收集器  

- 3.2.2 ParallelGC 垃圾收集器   
  
  ParallelGC收集器工作机制和ParNewGC收集器一样，只是在此基础之上，新增了两个和系统吞吐量相关的参数，使得其使用起来更加的灵活和高效 

相关参数如下： 

- -XX:+UseParallelGC
	- 年轻代使用ParallelGC垃圾回收器，老年代使用串行回收器  
- -XX:+UseParallelOldGC  
	- 年轻代、老年代都使用ParallelGC收集器     
- -XX:MaxGCPauseMillis  
	- 设置最大的垃圾收集时的停顿时间，单位为毫秒，收集器会尽量达到该时间，该参数谨慎使用   
- -XX:GCTimeRatio  
	- 设置垃圾回收时间占程序运行时间的百分比，公式为1/（1+n） 
	- 它的值为0~100之间的数字，默认值为99，也就是垃圾回收时间不能超过1%   
- -XX:UseAdaptiveSizePolicy  
	- 自适应GC模式，垃圾回收器将自动调整年轻代、老年代等参数，达到吞吐量、堆大小、停顿时间之间的平衡
	- 一般用于，手动调整参数比较困难的场景，让收集器自动进行调整  


> 3.3 CMS 垃圾收集器   
  CMS全称 Concurrent Mark Sweep，是一款并发的，使用标记-清除算法的垃圾回收器，   
  该收集器是针对老年代垃圾回收的，通过-XX:+UseConcMarkSweepGC进行设置  

  大致过程为：初始化标记----->并发标记----->预清理----->重新标记----->并发清除（与用户线程同时运行） ----->清理内存碎片----->并发重置（等待下次GC）   

> 3.4 G1垃圾收集器   
  G1垃圾收集器时再jdk1.7中正式使用的全新垃圾收集器，oracle官方计划在jdk1.9将G1   
  变成默认的垃圾收集器，以替代CMS   

  G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优      

- 第一步，开启G1垃圾收集器  
- 第二步，设置堆的最大内存 
- 第三步，设置最大停顿时间   

原理：G1垃圾收集器相对于其他收集器而言，最大的区别在于它取消了年轻代、老年代的物理划分，   取而代之的是将堆划分为若干个区域（Region）,这些区域中包含了有逻辑上的年轻代、老年代区域   

- Young GC 
	- Young GC 主要是对Eden进行GC,它在Eden空间耗尽时会被触发      
- Mixed GC  
	- 当年老代越来越多时，避免内存耗尽，会回收整个Young Region 和部分Old Region   
- Full GC     


<a id="part4"/>  
**4. GC Easy 可视化工具**   

GC Easy是一款在线的可视化工具，易用、功能强大   
  
网址：[https://gceasy.io/](https://gceasy.io/ "https://gceasy.io/")  

使用：配置JVM参数，导出gc日志文件，导入网站在线分析  

- -XX:+PrintGC 输出GC日志  
- -XX:+PrintGCDetails  输出GC的详细日志   
- -XX:+PrintGCTimeStamps 输出GC的时间戳(以基准时间的形式)   
- -XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2019-05-05T21:21:32.234+0800）  
-  -XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息    
-  -Xloggc:../logs/gc.log  日志文件的输出路径

